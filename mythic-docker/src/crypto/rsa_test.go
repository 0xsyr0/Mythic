package mythicCrypto

import (
	"reflect"
	"testing"
)

func TestRsaEncryptBytes(t *testing.T) {
	type args struct {
		plainBytes []byte
		publicKey  []byte
	}
	// TODO:
	// Hardcoded key here for now, should export and read from file
	pubPem := []byte{
		45, 45, 45, 45, 45, 66, 69, 71, 73, 78, 32, 82, 83, 65, 32, 80, 85, 66, 76, 73, 67, 32, 75, 69, 89, 45, 45, 45, 45, 45, 10, 77, 73, 73, 67, 67, 103, 75, 67, 65, 103, 69, 65, 51, 115, 80, 122, 49, 76, 89, 79, 52, 72, 47, 103, 56, 56, 109, 102, 103, 43, 84, 57, 110, 99, 43, 102, 57, 85, 69,
		68, 121, 85, 99, 50, 48, 55, 121, 81, 118, 80, 72, 52, 89, 57, 88, 107, 43, 104, 80, 112, 107, 104, 69, 84, 10, 105, 47, 116, 105, 69, 108, 77, 99, 101, 108, 108, 83, 50, 109, 69, 56, 75, 74, 108, 67, 114, 106, 57, 77, 87, 100, 49, 51, 56, 122, 118, 50, 66, 100, 53, 107, 69, 72, 110, 72,
		55, 82, 80, 108, 115, 72, 53, 68, 73, 79, 107, 117, 65, 47, 57, 67, 97, 90, 112, 100, 80, 53, 49, 77, 10, 48, 73, 97, 114, 88, 53, 82, 74, 52, 50, 112, 57, 74, 84, 84, 113, 88, 78, 51, 86, 73, 79, 65, 66, 114, 82, 49, 117, 81, 87, 106, 50, 115, 72, 53, 118, 85, 73, 70, 49, 103, 98, 79, 118,
		88, 116, 55, 120, 68, 88, 106, 54, 104, 66, 72, 110, 99, 84, 75, 53, 53, 47, 121, 77, 10, 107, 52, 86, 111, 55, 97, 99, 70, 97, 47, 122, 82, 48, 116, 119, 47, 122, 76, 48, 69, 76, 88, 65, 86, 74, 69, 109, 98, 47, 73, 98, 57, 77, 97, 69, 67, 121, 67, 76, 76, 108, 69, 86, 116, 90, 69, 120, 97,
		74, 113, 88, 103, 48, 110, 100, 100, 57, 85, 85, 110, 70, 108, 119, 89, 10, 97, 79, 75, 106, 47, 109, 106, 54, 70, 88, 48, 72, 105, 117, 67, 52, 109, 67, 86, 87, 119, 121, 68, 117, 103, 121, 72, 109, 116, 112, 118, 108, 70, 99, 115, 108, 97, 106, 89, 97, 68, 67, 118, 71, 52, 85, 109, 85, 98,
		53, 47, 107, 51, 97, 116, 49, 85, 112, 68, 122, 74, 57, 113, 50, 10, 100, 118, 110, 52, 116, 116, 54, 72, 83, 85, 68, 103, 99, 55, 104, 80, 85, 98, 81, 120, 70, 88, 73, 105, 88, 97, 110, 47, 69, 47, 49, 86, 55, 65, 105, 107, 70, 78, 116, 69, 120, 56, 57, 122, 118, 102, 87, 115, 111, 115, 108,
		113, 66, 79, 67, 104, 86, 71, 80, 119, 65, 51, 121, 119, 10, 75, 113, 104, 84, 89, 67, 49, 101, 106, 85, 52, 108, 106, 73, 72, 56, 47, 100, 50, 122, 101, 81, 89, 51, 53, 51, 53, 53, 101, 119, 68, 53, 101, 65, 65, 51, 84, 104, 113, 89, 82, 108, 53, 81, 100, 104, 48, 109, 76, 74, 119, 121, 103,
		80, 48, 120, 79, 90, 117, 43, 71, 47, 83, 99, 10, 90, 89, 107, 73, 82, 87, 82, 74, 48, 67, 109, 57, 97, 77, 75, 97, 105, 108, 81, 100, 47, 82, 74, 85, 53, 84, 105, 120, 83, 47, 68, 55, 67, 119, 53, 114, 103, 73, 49, 90, 119, 114, 113, 85, 81, 47, 49, 49, 68, 112, 65, 108, 105, 99, 106, 122,
		110, 118, 90, 48, 117, 108, 97, 121, 10, 47, 106, 53, 104, 113, 81, 104, 75, 52, 101, 113, 102, 99, 67, 49, 119, 76, 56, 100, 81, 74, 97, 114, 84, 121, 90, 103, 112, 88, 110, 52, 99, 73, 98, 80, 109, 107, 77, 54, 112, 77, 85, 101, 107, 97, 81, 78, 75, 47, 56, 108, 68, 116, 55, 51, 104, 65, 69,
		115, 105, 120, 55, 69, 71, 10, 106, 47, 104, 85, 117, 54, 86, 81, 54, 77, 78, 116, 104, 67, 122, 56, 109, 117, 72, 87, 98, 56, 119, 111, 117, 102, 115, 107, 104, 82, 51, 102, 107, 116, 51, 48, 48, 89, 77, 79, 122, 43, 112, 80, 54, 119, 97, 101, 73, 122, 51, 113, 71, 114, 85, 87, 84, 120, 121,
		47, 66, 114, 109, 118, 10, 49, 53, 118, 51, 74, 122, 65, 116, 77, 86, 84, 43, 81, 118, 117, 98, 75, 115, 115, 54, 49, 100, 51, 77, 70, 121, 50, 74, 121, 108, 56, 71, 118, 99, 98, 51, 110, 103, 90, 68, 74, 57, 88, 88, 86, 49, 52, 77, 100, 112, 120, 48, 74, 116, 77, 67, 65, 119, 69, 65, 65, 81,
		61, 61, 10, 45, 45, 45, 45, 45, 69, 78, 68, 32, 82, 83, 65, 32, 80, 85, 66, 76, 73, 67, 32, 75, 69, 89, 45, 45, 45, 45, 45, 10,
	}

	tests := []struct {
		name    string
		args    args
		wantLen int
		wantErr bool
	}{
		{
			name: "test RSA 4096 key success",
			args: args{
				plainBytes: []byte("test"),
				publicKey:  pubPem,
			},
			wantLen: 512,
			wantErr: false,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			got, err := RsaEncryptBytes(tt.args.plainBytes, tt.args.publicKey)
			if (err != nil) != tt.wantErr {
				t.Errorf("RsaEncryptBytes() error = %v, wantErr %v", err, tt.wantErr)
				return
			}
			if !reflect.DeepEqual(len(got), tt.wantLen) {
				t.Errorf("RsaEncryptBytes() = \n%v\n, want \n%v\n", len(got), tt.wantLen)
			}
		})
	}
}
